/*******************************************
 Initially Generated by SSoT.me - codee42 & odxml42
 Created By: EJ Alexandra - 2017
             An Abstract Level, llc
 License:    Mozilla Public License 2.0
 *******************************************/
using CLI;
using Plossum.CommandLine;
using SassyMQ.Lib.RabbitMQ;
using SassyMQ.SSOTME.Lib.RabbitMQ;
using SassyMQ.SSOTME.Lib.RMQActors;
using SSoTme.OST.Lib.DataClasses;
using SSoTme.OST.Lib.Extensions;
using SSoTme.OST.Lib.SassySDK.Derived;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using Newtonsoft.Json.Linq;
using System.Net.Http;
using SSoTme.OST.Core.Lib.Extensions;
using System.ComponentModel;
using Newtonsoft.Json;
using System.Net.Http.Json;

namespace SSoTme.OST.Lib.CLIOptions
{
    public class ProjectNotConfiguredException : Exception
    {
        public ProjectNotConfiguredException()
            : base("No ssotme project is configured in this directory.") { }
    }
    
    public class NoStackException : Exception
    {
        public NoStackException(string msg)
            : base(msg) { }
    }
    
    public partial class SSoTmeCLIHandler
    {
        // build scripts will make this match version from package.json
        public string CLI_VERSION = "2025.07.15";
        
        private SSOTMEPayload result;

        public SMQAccountHolder AccountHolder { get; private set; }
        public DMProxy CoordinatorProxy { get; private set; }


        private SSoTmeCLIHandler()
        {
            this.account = "";
            this.waitTimeout = 30000;
            this.input = new List<string>();
            this.OptionalInputCLIInputs = new List<string>();
            this.parameters = new List<string>();
            this.addSetting = new List<string>();
            this.removeSetting = new List<string>();
        }
        
        private SSoTmeProject GetProjectOrThrow()
        {
            if (this.AICaptureProject == null)
            {
                throw new ProjectNotConfiguredException();
            }
            return this.AICaptureProject;
        }
        
        public static SSoTmeCLIHandler CreateHandler(string commandLine)
        {
            var cliHandler = new SSoTmeCLIHandler();
            cliHandler.commandLine = commandLine;
            cliHandler.ParseCommand();
            return cliHandler;
        }


        public static SSoTmeCLIHandler CreateHandler(string[] args)
        {
            var cliOptions = new SSoTmeCLIHandler();
            cliOptions.args = args;
            cliOptions.ParseCommand();
            return cliOptions;
        }

        private void HandleInfoCommand()
        {
            try
            {
                var key = SSOTMEKey.GetSSoTmeKey(this.runAs);
                string runas = this.runAs;
                if (String.IsNullOrEmpty(runas))
                {
                    runas = "ssotme.key";
                }
                else
                {
                    runas += ".key";
                }
                Console.WriteLine($"\nSSoTme CLI Version {this.CLI_VERSION}\n\nConfiguration for `{runas}`:");
                Console.WriteLine($"Email Address: {key.EmailAddress}");
                Console.WriteLine($"Secret: {key.Secret}");
                
                // Display API keys if they exist
                if (key.APIKeys != null && key.APIKeys.Count > 0)
                {
                    Console.WriteLine("Configured API keys:");
                    foreach (var kvp in key.APIKeys)
                    {
                        Console.WriteLine($"  {kvp.Key}: {kvp.Value}");
                    }
                }
                else
                {
                    Console.WriteLine("No API keys configured.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Error retrieving configuration: {e.Message}");
            }
        }

        private void ParseCommand()
        {
            try
            {
                CommandLineParser parser = new CommandLineParser(this);
                if (!String.IsNullOrEmpty(this.commandLine)) parser.Parse(this.commandLine, false);
                else parser.Parse(this.args, false);

                var remainingArguments = parser.RemainingArguments.ToList();
                this.FixParameters(ref remainingArguments);

                this.HasRemainingArguments = remainingArguments.Any();
                this.RemainingArguments = remainingArguments;

                bool continueToLoad = false;

                if (String.IsNullOrEmpty(this.transpiler))
                {
                    this.transpiler = remainingArguments.FirstOrDefault().SafeToString();
                    if (this.transpiler.Contains("/"))
                    {
                        this.account = this.transpiler.Substring(0, this.transpiler.IndexOf("/"));
                        this.transpiler = this.transpiler.Substring(this.transpiler.IndexOf("/") + 1);
                    }
                }

                var additionalArgs = remainingArguments.Skip(1).ToList();
                for (var i = 0; i < additionalArgs.Count; i++)
                {
                    this.parameters.Add(String.Format("param{0}={1}", i + 1, additionalArgs[i]));
                }


                if (this.help)
                {
                    var helpWidth = Console.WindowWidth - 4;
                    Console.WriteLine(parser.UsageInfo.GetHeaderAsString(helpWidth));

                    Console.WriteLine("\n\nSyntax: ssotme [account/]transpiler [Options]\n\n");

                    Console.WriteLine(parser.UsageInfo.GetOptionsAsString(helpWidth));
                    Console.ReadKey();
                    this.SuppressTranspile = true;
                }
                else if (this.info)
                {
                    this.HandleInfoCommand();
                    continueToLoad = false;
                    this.SuppressTranspile = true;
                }
                else if (this.version)
                {
                    Console.WriteLine(this.CLI_VERSION);
                    this.SuppressTranspile = true;
                    this.SuppressKeyPress = true;
                    continueToLoad = false;
                }
                else if (this.init)
                {
                    if (String.IsNullOrEmpty(this.projectName))
                    {
                        this.projectName = Path.GetFileName(Environment.CurrentDirectory);
                    }

                    var force = this.args.Count() == 2 && this.args[1] == "force";

                    DataClasses.AICaptureProject.Init(force, this.projectName);

                    continueToLoad = true;
                    this.build = true;
                }
                else if (parser.HasErrors)
                {
                    var curColor = Console.ForegroundColor;
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine(parser.UsageInfo.GetErrorsAsString(78));
                    this.ParseResult = -1;
                    Console.ForegroundColor = curColor;
                    this.SuppressTranspile = true;
                }
                else if (this.authenticate || this.discuss || this.listSeeds || this.cloneSeed)
                {
                    continueToLoad = false;
                }
                else continueToLoad = true;

                // Check for api keys

                if (continueToLoad)
                {
                    if (String.IsNullOrEmpty(this.setAccountAPIKey) && !this.help && !this.authenticate && !this.listSeeds && !this.cloneSeed)
                    {
                        this.AICaptureProject = SSoTmeProject.LoadOrFail(new DirectoryInfo(Environment.CurrentDirectory), false, this.clean || this.cleanAll);
                        if (this.AICaptureProject is null) {
                            // warn user for clarity
                            ShowError("WARN: SSoTme project is null. Run `ssotme -init` to create a new one in this directory.", ConsoleColor.Yellow);
                        }
                        
                        // still can continue with basic transpilers
                        foreach (var projectSetting in this.AICaptureProject?.ProjectSettings ?? new BindingList<ProjectSetting>())
                        {
                            if (!this.parameters.Any(anyParam => anyParam.StartsWith(String.Format("{0}=", projectSetting.Name))))
                            {
                                this.parameters.Add(String.Format("{0}={1}", projectSetting.Name, projectSetting.Value));
                            }
                        }
                        
                    }
                    this.LoadInputFiles();

                    var key = SSOTMEKey.GetSSoTmeKey(this.runAs);
                    if (key.APIKeys.ContainsKey(this.account))
                    {
                        this.parameters.Add(String.Format("apiKey={0}", key.APIKeys[this.account]));
                    }

                    if (!ReferenceEquals(this.FileSet, null))
                    {
                        this.ZFSFileSetFile = this.FileSet.FileSetFiles.FirstOrDefault(fodFileSetFile => fodFileSetFile.RelativePath.EndsWith(".zfs", StringComparison.OrdinalIgnoreCase));
                    }
                }
            }
            catch (Exception ex)
            {
                var curColor = Console.ForegroundColor;
                Console.ForegroundColor = ConsoleColor.Red;

                var currentException = ex;
                while (!(currentException is null))
                {
                    Console.WriteLine("\n********************************\nERROR: {0}\n********************************\n\n", currentException.Message);
                    Console.WriteLine(currentException.StackTrace);
                    Console.WriteLine("\n\nPress any key to continue...\n");
                    Console.WriteLine("\n\n");
                    if (currentException == ex.InnerException) break;
                    currentException = ex.InnerException;
                }
                Console.ForegroundColor = curColor;
                this.SuppressTranspile = true;
                Console.ReadKey();
            }
        }

        private GitRepo? ListSeeds(bool allowChoice, string requestedSeedName)
        {
            try
            {
                var publicRepos = GetPublicReposAsync("ssotme").GetAwaiter().GetResult();
                var allSeeds = publicRepos.Where(repo => repo.Name.Contains("seed"));
                var roots = allSeeds.Where(seed => seed.Name.Contains("root")).ToList();
                var seeds = allSeeds.Where(seed => !seed.Name.Contains("root")).ToList();

                // Set console window width to 90% of current width for wrapping
                int maxLineWidth = Math.Max((int)(Console.WindowWidth * 0.9) - 15, 60);

                Console.ResetColor();

                if (this.IsCurrentSeedRoot())
                {
                    if (!String.IsNullOrEmpty(requestedSeedName))
                    {
                        var selectedSeed = seeds.FirstOrDefault(fod => fod.Name.Equals(requestedSeedName, StringComparison.OrdinalIgnoreCase) ||
                                                                        fod.ShortName.Equals(requestedSeedName, StringComparison.OrdinalIgnoreCase));
                        if (selectedSeed is null) throw new Exception($"Requested seed not found: {requestedSeedName}");

                        return selectedSeed;
                    }
                    // Formatting for regular seeds
                    Console.ForegroundColor = ConsoleColor.Green; // Header in green
                    Console.WriteLine("\n\nPublic ssot.me starter seeds.");
                    Console.ResetColor();

                    return ListAndPickSeed(seeds, allowChoice, maxLineWidth);
                }
                else
                {
                    // Formatting for ROOT seeds
                    Console.ForegroundColor = ConsoleColor.Green; // Header in green
                    Console.WriteLine(@"Public ssot.me ROOT starter seeds.
These seeds are designed to connect to a specific data source, 
such as Airtable, MySQL, Postgress, GSheets, etc...

They typically include the schema, role based permissions,
documentation, along with other meta data about the datasource,
such as which tables have authorization data, email addresses,
roles, etc (if appropriate).
");

                    return ListAndPickSeed(roots, allowChoice, maxLineWidth);
                }
            }
            finally
            {
                // Footer text
                Console.ForegroundColor = ConsoleColor.White; // Default text color for the rest
                Console.WriteLine(@"
Go to https://github.com/ssotme for a current list of public Seeds available.

Syntax: 
     > ssotme -cloneseed https://github.com/ssotme/root-seed-mysql [seed-directory]\n\n\n");
                Console.ResetColor();
            }
        }

        private static GitRepo ListAndPickSeed(List<GitRepo> seeds, bool allowChoice, int maxLineWidth)
        {
            var selectedSeed = default(GitRepo);

            int seedNumber = 1;
            seeds.ForEach(seed =>
            {
                var seedName = seed.Name.Replace("root-", "");
                seedName = seedName.Replace("seed-", "");
                Console.ForegroundColor = ConsoleColor.Cyan; // Root seeds in cyan
                var seedSyntax1 = $"\n{seedNumber++} - {WrapText(seedName, maxLineWidth)}";
                seedSyntax1 += $"{"".PadLeft(Math.Max(0, 25 - seedSyntax1.Length))} > ssotme -cloneseed";
                var seedSyntax2 = $" {seedName} ";
                var seedSyntax3 = $"my-{seedName}";
                var lines = $"{WrapText(seed.Description, maxLineWidth)}".Split(Environment.NewLine).ToList();
                var description = String.Join(",\n", lines.Select(str => $"{"".PadRight(27)}{str}"));

                Console.Write($"{seedSyntax1}");
                Console.ForegroundColor = ConsoleColor.Blue; // Root seeds in cyan
                Console.Write($"{seedSyntax2}");
                Console.ForegroundColor = ConsoleColor.Cyan; // Root seeds in cyan
                Console.WriteLine($"{seedSyntax3}");
                Console.WriteLine($"{description}");
                Console.WriteLine();
                Console.ResetColor();
            });

            if (allowChoice)
            {
                Console.Write("Enter the number of the seed to clone here: ");
                var readLn = Console.ReadLine();
                if (Int32.TryParse(readLn, out int rootSeedSelected))
                {
                    selectedSeed = seeds[rootSeedSelected - 1];
                }
            }

            return selectedSeed;
        }

        private bool IsCurrentSeedRoot()
        {
            var ssotmeFile = new FileInfo("ssotme.json");

            // Check if the ssotme.json file exists in the current directory
            if (!ssotmeFile.Exists) return false;

            try
            {
                // Parse the JSON content of the ssotme.json file
                var jsonContent = File.ReadAllText(ssotmeFile.FullName);
                var project = JObject.Parse(jsonContent);

                // Access the Transpilers array and check if any of the transpiler groups match "ssot"
                var transpilers = project["ProjectTranspilers"] as JArray;
                if (transpilers != null)
                {
                    return transpilers.Any(tp =>
                        string.Equals((string)tp["TranspilerGroup"], "ssot", StringComparison.OrdinalIgnoreCase));
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error parsing ssotme.json: {ex.Message}");
            }

            return false;
        }

        // Helper function to wrap text to the specified width
        private static string WrapText(string text, int maxWidth)
        {
            if (string.IsNullOrEmpty(text) || text.Length <= maxWidth) return text;

            var lines = new List<string>();
            var words = text.Split(' ');

            var currentLine = string.Empty;
            foreach (var word in words)
            {
                if ((currentLine.Length + word.Length + 1) > maxWidth)
                {
                    lines.Add(currentLine);
                    currentLine = word;
                }
                else
                {
                    currentLine += (currentLine.Length > 0 ? " " : "") + word;
                }
            }
            lines.Add(currentLine); // Add the last line

            return string.Join(Environment.NewLine, lines);
        }

        public class GitRepo
        {
            public string Name { get; set; }
            public string Description { get; set; }
            public string ShortName => $"{this.Name}".Replace("root-", "").Replace("seed-", "");
            public string Url { get => $"https://github.com/ssotme/{this.Name}"; }
        }

        public static async Task<List<GitRepo>> GetPublicReposAsync(String account)
        {
            var apiUrl = $"https://api.github.com/users/{account}/repos";
            var reposList = new List<GitRepo>();

            using (var client = new HttpClient())
            {
                client.DefaultRequestHeaders.Add("User-Agent", "request"); // GitHub API requires a user-agent header

                try
                {
                    var response = await client.GetStringAsync(apiUrl);
                    JArray repos = JArray.Parse(response);

                    foreach (JObject repo in repos)
                    {
                        string name = repo["name"].ToString();
                        string description = repo["description"].ToString();
                        var repoMetaData = new GitRepo() { Name = name, Description = description } ;
                        reposList.Add(repoMetaData);
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error fetching repository data: {ex.Message}");
                    // Optionally, handle exceptions in a way that suits your application's needs
                }
            }

            reposList.Add(new GitRepo() { Name = "seed-airtable-dotnet-api", Description = "An EffortlessAPI for Airtable Dotnet REST-API, Swagger documentation." });
            reposList.Add(new GitRepo() { Name = "seed-golang-dotnet-api", Description = "An EffortlessAPI for Airtable Golang REST-API, Swagger documentation." });

            return reposList;
        }

        private async Task<string> CloneSeed(GitRepo seedRepo)
        {
            string seedRepoUrl = seedRepo?.Url;
            seedRepoUrl = seedRepoUrl ?? this.GetSeedUrl();
            string initialDirectoryName = this.RemainingArguments.FirstOrDefault();
            return seedRepo.CloneRepositoryUsingCmd(initialDirectoryName);
        }

        private string _cachedSeedUrl;

        private string GetSeedUrl()
        {
            if (String.IsNullOrEmpty(this._cachedSeedUrl))
            {
                var seedRepoUrl = this.RemainingArguments.FirstOrDefault();
                if (String.IsNullOrEmpty(seedRepoUrl))
                {
                    Console.Write(@"Please enter the git url for the seed repository that you would like to clone.  Press ENTER to abort.
eg: https://github.com/your-account/your-seed.git
or: git@github.com:your-account/your-seed

Seed Url: ");
                    seedRepoUrl = Console.ReadLine();
                }
                else RemainingArguments.RemoveAt(0);
                _cachedSeedUrl = seedRepoUrl;
            }
            return _cachedSeedUrl;
        }


        private void FixParameters(ref List<string> additionalArgs)
        {
            var cmd = additionalArgs.FirstOrDefault();
            switch ($"{cmd}".ToLower())
            {
                case "init":
                    this.init = true;
                    break;

                case "help":
                    this.help = true;
                    break;

                case "install":
                    this.install = true;
                    break;

                case "cloneseed":
                case "clone":
                    this.cloneSeed = true;
                    break;

                case "listseeds":
                    this.listSeeds = true;
                    break;

                case "build":
                case "buildLocal":
                case "rebuild":
                case "pull":
                    this.build = true;
                    break;

                case "buildall":
                case "rebuildall":
                case "pullAll":
                    this.buildAll = true;
                    break;

                case "clean":
                    this.clean = true;
                    break;

                case "cleanall":
                    this.cleanAll = true;
                    break;

                case "describe":
                    this.describe = true;
                    break;

                case "descibeAll":
                    this.descibeAll = true;
                    break;

                default:
                    return;
            }

            this.transpiler = additionalArgs.Skip(1).FirstOrDefault();
            if (additionalArgs.Count > 0) additionalArgs.RemoveAt(0);
        }

        public int TranspileProject(ProjectTranspiler projectTranspiler = null)
        {
            bool updateProject = false;
            try
            {
                var hasRemainingArguments = this.HasRemainingArguments;
                var zfsFileSetFile = this.ZFSFileSetFile;
                if (this.authenticate)
                {
                    if (!this.CheckAuthenticationNow())
                    {
                        return -1;
                    }
                }
                else if (this.describe)
                {
                    GetProjectOrThrow().Describe(Environment.CurrentDirectory);
                }
                else if (this.descibeAll)
                {
                    GetProjectOrThrow().Describe();
                }
                else if (this.listSettings)
                {
                    GetProjectOrThrow().ListSettings();
                }
                else if (this.addSetting.Any())
                {
                    foreach (var setting in this.addSetting)
                    {
                        GetProjectOrThrow().AddSetting(setting);
                    }

                    this.AICaptureProject.Save();
                }
                else if (this.listSeeds)
                {
                    this.ListSeeds(false, null);
                    this.SuppressTranspile = true;
                }
                else if (this.cloneSeed)
                {
                    this.InitiateCloneSeedingProcess();
                    this.SuppressTranspile = true;
                }
                else if (this.removeSetting.Any())
                {
                    foreach (var setting in this.removeSetting)
                    {
                        GetProjectOrThrow().RemoveSetting(setting);
                    }
                    this.AICaptureProject.Save();
                }
                else if (!String.IsNullOrEmpty(this.setAccountAPIKey))
                {
                    var key = SSOTMEKey.GetSSoTmeKey(this.runAs);
                    if (ReferenceEquals(key.APIKeys, null)) key.APIKeys = new Dictionary<String, String>();
                    var apiKey = this.setAccountAPIKey.SafeToString().Replace("=", "/");
                    var values = apiKey.Split("/".ToCharArray());

                    if (values[0].Equals("baserow", StringComparison.OrdinalIgnoreCase))
                    { // special case for baserow, where we need the username and password
                        // -setAccountAPIKey=baserow/username/password
                        if (values.Length < 3)
                        {
                            ShowError("Syntax for \"baserow\": -setAccountAPIKey=baserow/username/password");
                            return -1;
                        }

                        var baserowConf = new { username = values[1], password = values[2] };
                        key.APIKeys["baserow"] = JsonConvert.SerializeObject(baserowConf);
                    }
                    else
                    {
                        if (!values.Skip(1).Any())
                        {
                            ShowError("Default Syntax: -setAccountAPIKey=account/KEY");
                            return -1;
                        }
                        key.APIKeys[values[0]] = values[1];
                    }
                    SSOTMEKey.SetSSoTmeKey(key, this.runAs);
                }
                else if (!String.IsNullOrEmpty(this.execute))
                {
                    this.ProcessCommandLine(this.execute);
                    if (this.install)
                    {
                        result = new SSOTMEPayload()
                        {
                            Transpiler = new Transpiler()
                            {
                                Name = "-execute"
                            }
                        };
                        this.AICaptureProject.Install(result, this.transpilerGroup);
                    }
                }
                else if (this.build || this.buildLocal)
                {
                    GetProjectOrThrow().Rebuild(Environment.CurrentDirectory, this.includeDisabled, this.transpilerGroup, this.buildOnTrigger, this.copilotConnect, this.buildLocal);
                }
                else if (this.buildAll)
                {
                    GetProjectOrThrow().RebuildAll(this.AICaptureProject.RootPath, this.includeDisabled, this.transpilerGroup, this.buildOnTrigger, this.copilotConnect, this.buildLocal);
                }
                else if (this.discuss)
                {
                    var aicManager = AICManager.Create(this.Auth0SID);
                    aicManager.Start();
                }
                else if (this.checkResults || this.createDocs && !hasRemainingArguments)
                {
                    GetProjectOrThrow().CreateDocs(this.checkResults);
                    updateProject = true;
                }
                else if (this.clean && !ReferenceEquals(zfsFileSetFile, null))
                {
                    var possiblyOptionalFileName = zfsFileSetFile.RelativePath;
                    var zfsFI = new FileInfo(possiblyOptionalFileName);
                    if (zfsFI.Exists)
                    {
                        var zippedFileSet = File.ReadAllBytes(zfsFI.FullName);
                        zippedFileSet.CleanZippedFileSet();
                        if (!this.preserveZFS) zfsFI.Delete();
                    }
                }
                else if (this.clean && !hasRemainingArguments)
                {
                    this.AICaptureProject?.Clean(Environment.CurrentDirectory, this.preserveZFS);
                    Task.Run(() => new DirectoryInfo(Environment.CurrentDirectory).ApplySeedReplacementsAsync(true)).Wait();

                }
                else if (this.cleanAll && !hasRemainingArguments)
                {
                    this.AICaptureProject?.CleanAll(this.preserveZFS);
                    Task.Run(() => new DirectoryInfo(Environment.CurrentDirectory).ApplySeedReplacementsAsync(true)).Wait();
                }
                else if (!hasRemainingArguments && !this.clean && String.IsNullOrEmpty(this.TargetUrl))
                {
                    ShowError("Missing argument name of transpiler");
                    return -1;
                }
                else
                {
                    StartTranspile();

                    if (!ReferenceEquals(result.Exception, null))
                    {
                        var nextException = result.Exception;
                        while (!(nextException is null))
                        {
                            ShowError("ERROR: " + nextException.Message);
                            ShowError(nextException.StackTrace);
                            nextException = nextException.InnerException;
                        };
                        return -1;
                    }
                    else
                    {
                        var finalResult = 0;

                        if (!ReferenceEquals(result.Transpiler, null))
                        {
                            //Console.WriteLine("\n\nTRANSPILER MATCHED: {0}\n\n", result.Transpiler.Name);
                        }

                        if (this.clean) result.CleanFileSet();
                        else
                        {
                            finalResult = result.SaveFileSet(this.skipClean);
                            updateProject = true;
                        }
                        return finalResult;

                    }
                }

                return 0;
            }
            finally
            {
                if (!ReferenceEquals(AccountHolder, null)) AccountHolder.Disconnect();
                if (updateProject)
                {
                    if (this.install) this.AICaptureProject.Install(result, this.transpilerGroup);
                    else if (!ReferenceEquals(projectTranspiler, null))
                    {
                        GetProjectOrThrow().Update(projectTranspiler, result);
                    }
                }
            }
        }

        private void InitiateCloneSeedingProcess()
        {
            var requestedSeedName = this.RemainingArguments.FirstOrDefault();
            var seed = this.ListSeeds(true, requestedSeedName);
            if (seed is null) return;
            string seedRootPath = default;
            var task = Task.Run(async () => seedRootPath = await this.CloneSeed(seed));
            task.Wait(300000);
            if (!task.IsCompleted || !(task.Exception is null)) throw new Exception($"Unable to clone repo {task.Exception.Message}", task.Exception);
            var seedDI = new DirectoryInfo(seedRootPath);
            seedDI.CheckSSoTmeCache(seed.Name);
            seedDI.InvokeSSoTmeBuild();
            seedDI.StartSeedBuild();
        }

        private bool CheckAuthenticationNow()
        {
            Console.WriteLine("Authenticating with auth0.");
            if (!String.IsNullOrEmpty(this.Auth0SID))
            {
                this.PrintAuth();
                Console.WriteLine("Already authenticated.  Reauthenticate now? y/N");
                if (Console.ReadKey().Key != ConsoleKey.Y) return true;
            }

            var startInfo = new ProcessStartInfo();
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                startInfo.FileName = "cmd";
                startInfo.Arguments = $"/c start chrome {this.AICaptureHost}/cli-login";
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                startInfo.FileName = "xdg-open";
                startInfo.Arguments = $"{this.AICaptureHost}/cli-login";
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                startInfo.FileName = "open";
                startInfo.Arguments = $"{this.AICaptureHost}/cli-login";
            }
            else
            {
                throw new InvalidOperationException("Unsupported operating system");
            }

            startInfo.UseShellExecute = false;
            startInfo.RedirectStandardInput = true;
            startInfo.CreateNoWindow = true;

            var process = new Process { StartInfo = startInfo };
            process.Start();
            process.StandardInput.Close();

            var result = LocalServer.StartServerAsync("http://localhost:8080/complete-cli/");
            result.Wait(300000);
            if (result.IsCompleted)
            {
                object jwtFromRedirect = $"result: {result.Result}";
                this.Auth0SID = result.Result;
                this.PrintAuth();
                return true;
            }
            else
            {
                ShowError("Syntax: ssotme unable to authenticate within the specified timeout period.");
                return false;
            }
        }

        private void PrintAuth()
        {
            var webClient = new WebClient();
            var payload = $"{{ \"Auth0SID\":\"{this.Auth0SID}\" }}";
            var resultBytes = webClient.UploadData($"{this.AICaptureHost}/whoami", Encoding.UTF8.GetBytes(payload));
            var jwt = Encoding.UTF8.GetString(resultBytes);
            Console.WriteLine(jwt);
        }

        private void PublicUser_ReplyTo(object sender, PayloadEventArgs<SSOTMEPayload> e)
        {
            if (e.Payload.IsLexiconTerm(LexiconTermEnum.publicuser_ping_ssotmecoordinator))
            {
                this.CoordinatorProxy = new DMProxy(e.Payload.DirectMessageQueue);
                var payload = this.PublicUser.CreatePayload();
                throw new Exception("This: payload.EmailAddress = this.emailAddress; isn't really a thing anymore.");
                this.PublicUser.PublicUserAuthenticate(payload, this.CoordinatorProxy);
            }
            else if (e.Payload.IsLexiconTerm(LexiconTermEnum.publicuser_authenticate_ssotmecoordinator))
            {
                Console.WriteLine("We sent an auth key to {0}.", e.Payload.EmailAddress);
                Console.Write("AUTH Code: ");
                e.Payload.AuthToken = Console.ReadLine();
                if (!String.IsNullOrEmpty(e.Payload.AuthToken))
                {
                    Console.WriteLine("Validating AUTH Code.  One moment...");
                    this.PublicUser.PublicUserValidateAuthToken(e.Payload, this.CoordinatorProxy);
                }
                else
                {
                    Console.WriteLine("Aborting. No AUTH Code recieved.");
                }
            }
            else if (e.Payload.IsLexiconTerm(LexiconTermEnum.publicuser_validateauthtoken_ssotmecoordinator))
            {
                if (String.IsNullOrEmpty(e.Payload.Secret))
                {
                    Console.WriteLine("AUTH Code Validated Failed.");
                }
                else
                {
                    Console.WriteLine("AUTH Code Validated.");
                    try
                    {
                        var key = SSOTMEKey.GetSSoTmeKey(this.account);
                        key.EmailAddress = e.Payload.EmailAddress;
                        key.Secret = e.Payload.Secret;
                        SSOTMEKey.SetSSoTmeKey(key, this.account);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("ERROR: {0}", ex.Message);
                    }
                }
                Console.WriteLine("Press enter to continue.");
                Console.ReadLine();
                this.PublicUser.Disconnect();
            }
        }

        private static void ShowError(string msg, ConsoleColor color = ConsoleColor.Red)
        {
            var curColor = Console.ForegroundColor;
            Console.ForegroundColor = color;
            Console.WriteLine(msg);
            Console.ForegroundColor = curColor;
        }

        private void ProcessCommandLine(string commandLine)
        {
            var cmd = $"{commandLine} ";
            var executable = cmd.Substring(0, cmd.IndexOf(" "));
            var args = cmd.Substring(executable.Length + 1);
            var psi = new ProcessStartInfo(executable, args);
            try
            {
                var process = Process.Start(psi);
                process.WaitForExit(this.waitTimeout);
                if (!process.HasExited)
                {
                    process.Close();
                    throw new NoStackException(String.Format("Timed out waiting for process to complete: {0}", commandLine));
                }
            }
            catch (System.ComponentModel.Win32Exception ex)
            {
                throw new NoStackException($"The system couldn't find the command \"{executable}\"");
            }
        }

        internal void LoadOutputFiles(String lowerHyphoneName, String basePath, bool includeContents)
        {
            var rootPath = ReferenceEquals(this.AICaptureProject, null) ? Environment.CurrentDirectory : this.AICaptureProject.RootPath;
            var zfsRelativePath = String.Format("{0}.zfs", lowerHyphoneName);
            basePath = basePath.Trim("\\/".ToCharArray());
            var zfsFileName = Path.Combine(rootPath, ".ssotme", basePath, zfsRelativePath);

            var zfsFI = new FileInfo(zfsFileName);
            if (zfsFI.Exists)
            {
                var fileSetXml = File.ReadAllBytes(zfsFI.FullName).UnzipToString();
                var fs = fileSetXml.ToFileSet();
                foreach (var fsf in fs.FileSetFiles)
                {
                    var relativePath = fsf.RelativePath.Trim("\\/\r\n\t ".ToCharArray());
                    fsf.OriginalRelativePath = Path.Combine(basePath, relativePath).Replace("\\", "/");
                    if (!includeContents) fsf.ClearContents();
                }
                this.OutputFileSet = fs;
            }
        }

        private void StartTranspile()
        {
            this.AccountHolder = new SMQAccountHolder();
            var currentSSoTmeKey = SSOTMEKey.GetSSoTmeKey(this.runAs);
            result = null;

            this.AccountHolder.ReplyTo += AccountHolder_ReplyTo;
            this.AccountHolder.Init(currentSSoTmeKey.EmailAddress, currentSSoTmeKey.Secret);


            var waitForCook = Task.Factory.StartNew(() =>
            {
                while (ReferenceEquals(result, null)) Thread.Sleep(100);
            });

            waitForCook.Wait(this.waitTimeout);

            if (ReferenceEquals(result, null))
            {
                result = AccountHolder.CreatePayload();
                result.Exception = new TimeoutException("Timed out waiting for cook");
            }
            result.SSoTmeProject = this.AICaptureProject;
        }

        public string inputFileContents = "";
        public string transpiler = "";
        public string inputFileSetXml;
        public string[] args;
        public string commandLine;
        private SMQPublicUser PublicUser;
        public string inputFileSetJson;

        public FileSet FileSet { get; private set; }
        public bool HasRemainingArguments { get; private set; }
        public List<string> RemainingArguments { get; private set; }
        public FileSetFile ZFSFileSetFile { get; private set; }
        public SSoTmeProject AICaptureProject { get; set; }
        public int ParseResult { get; private set; }
        public FileSet OutputFileSet { get; private set; }
        public bool SuppressTranspile { get; private set; }
        public bool SuppressKeyPress { get; private set; }
        
        public string AICaptureHost
        {
            get
            {
#if DEBUG
                return "https://localhost:7033";
#else
                return "https://aicapture.io";
#endif
            }
        }
        public string Auth0SID
        {
            get
            {
                if (Auth0TokenFI.Exists) return File.ReadAllText(Auth0TokenFI.FullName);
                else return String.Empty;
            }
            set
            {
                File.WriteAllText(Auth0TokenFI.FullName, value);
            }
        }

        private static FileInfo Auth0TokenFI
        {
            get
            {
                var auth0TokenPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".aicapture", "auth0.key");
                var auth0TokenFI = new FileInfo(auth0TokenPath);
                if (!auth0TokenFI.Directory.Exists) auth0TokenFI.Directory.Create();
                return auth0TokenFI;
            }
        }

        public List<string> OptionalInputCLIInputs { get; internal set; }
        private void SaveOptionalCLIInputs()
        {
            this.OptionalInputCLIInputs = this.OptionalInputCLIInputs ?? new List<string>();
            var inputFileCount = this.input is null ? 0 : input.Count();
            for (int fileIndex = 0; fileIndex < inputFileCount; fileIndex++)
            {
                var inputFileName = input[fileIndex];
                if ((inputFileName ?? "").EndsWith("?"))
                {
                    var concreteFileName = inputFileName.TrimEnd('?');
                    input[inputFileCount] = concreteFileName;
                    this.OptionalInputCLIInputs.Add(concreteFileName);
                }
            }
        }


        public void LoadInputFiles()
        {
            this.SaveOptionalCLIInputs();
            var fs = new FileSet();
            if (!ReferenceEquals(this.input, null) && this.input.Any())
            {
                foreach (var input in this.input)
                {
                    if (!String.IsNullOrEmpty(input))
                    {
                        var inputFilePatterns = input.Split(",".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                        foreach (var filePattern in inputFilePatterns)
                        {
                            this.ImportFile(filePattern, fs);
                        }

                        if (fs.FileSetFiles.Any()) this.inputFileContents = fs.FileSetFiles.First().FileContents;

                    }
                }
            }
            this.inputFileSetXml = fs.ToXml();
            this.FileSet = fs;
        }

        private void ImportFile(string filePattern, FileSet fs)
        {
            var fileNameReplacement = String.Empty;
            if (filePattern.Contains("="))
            {
                fileNameReplacement = filePattern.Substring(0, filePattern.IndexOf("="));
                filePattern = filePattern.Substring(filePattern.IndexOf("=") + 1);
            }
            var di = new DirectoryInfo(Path.Combine(".", Path.GetDirectoryName(filePattern)));
            filePattern = Path.GetFileName(filePattern);

            var matchingFiles = new FileInfo[] { };
            if (di.Exists)
            {
                matchingFiles = di.GetFiles(filePattern);
            }
            if (!matchingFiles.Any() && !this.OptionalInputCLIInputs.Contains(filePattern))
            {
                var curColor = Console.ForegroundColor;
                Console.ForegroundColor = ConsoleColor.Yellow;
                Console.WriteLine("\n\nWARNING:\n\n - No INPUT files matched {0} in {1}\n", filePattern, di.FullName);
                var fsf = new FileSetFile();
                fsf.RelativePath = Path.GetFileName(filePattern);
                fs.FileSetFiles.Add(fsf);

                Console.ForegroundColor = curColor;

            }

            foreach (var matchingFileFI in matchingFiles)
            {
                var fsf = new FileSetFile();
                fsf.RelativePath = String.IsNullOrEmpty(fileNameReplacement) ? matchingFileFI.Name : fileNameReplacement;
                var projectRootLength = this.AICaptureProject.RootPath.Length;
                var matchingFileFILength = matchingFileFI.Directory.FullName.Length;
                var minLength = Math.Min(projectRootLength, matchingFileFILength);
                fsf.OriginalRelativePath = matchingFileFI.FullName.Substring(minLength).Replace("\\", "/");
                fs.FileSetFiles.Add(fsf);

                if (matchingFileFI.Exists)
                {
                    if (matchingFileFI.IsBinaryFile())
                    {
                        fsf.ZippedBinaryFileContents = File.ReadAllBytes(matchingFileFI.FullName).Zip();
                    }
                    else
                    {
                        fsf.ZippedFileContents = File.ReadAllText(matchingFileFI.FullName).Zip();
                    }
                }
                else
                {
                    var curColor = Console.ForegroundColor;
                    Console.ForegroundColor = ConsoleColor.Yellow;
                    Console.WriteLine("INPUT Format: {0} did not match any files in {1}", filePattern, di.FullName);
                    Console.ForegroundColor = curColor;
                }
            }
        }

        private async void AccountHolder_ReplyTo(object sender, SassyMQ.Lib.RabbitMQ.PayloadEventArgs<SSOTMEPayload> e)
        {
            var payload = AccountHolder.CreatePayload();
            payload.SaveCLIOptions(this);
            if (!String.IsNullOrEmpty(this.TargetUrl))
            {
                using var client = new HttpClient();
                payload.TranspileRequest = new TranspileRequest();
                payload.TranspileRequest.ZippedInputFileSet = this.inputFileSetXml.Zip();
                var response = await client.PostAsJsonAsync($"{this.TargetUrl}", payload);
                if (response != null)
                {
                    var responseContent = await response.Content.ReadAsStringAsync();
                    var responsePayload = JsonConvert.DeserializeObject<SSOTMEPayload>(responseContent);
                    result = responsePayload;
                    if (result != null)
                    {
                        result.SSoTmeProject = this.AICaptureProject;
                        if (this.clean) result.CleanFileSet();
                        else
                        {
                            var finalResult = result.SaveFileSet(this.skipClean);
                        }
                    }
                }
            }
            if (e.Payload.IsLexiconTerm(LexiconTermEnum.accountholder_ping_ssotmecoordinator))
            {
                CoordinatorProxy = new DMProxy(e.Payload.DirectMessageQueue);
                //Console.WriteLine("Got ping response");

                payload.TranspileRequest = new TranspileRequest();
                payload.TranspileRequest.ZippedInputFileSet = this.inputFileSetXml.Zip();
                payload.CLIInputFileContents = String.Empty;
                AccountHolder.AccountHolderCommandLineTranspile(payload, CoordinatorProxy);
            }
            else if (e.Payload.IsLexiconTerm(LexiconTermEnum.accountholder_commandlinetranspile_ssotmecoordinator) ||
                    (e.Payload.IsLexiconTerm(LexiconTermEnum.accountholder_requesttranspile_ssotmecoordinator)))
            {
                result = e.Payload;
            }
        }
    }
}
